# é€™æ˜¯ç”¨è‡ªå‹•ä»£ç†å¯«çš„ç¬¬ä¸€ç‰ˆ é–‹å€‰ æœªæ¸¬è©¦


# =======================
# ğŸ”’ Step 1: å®‰è£ä¾è³´
# =======================
!pip install requests

# =======================
# ğŸ“„ Step 2: è¨­å®š API é‡‘é‘°
# =======================
API_KEY = "ä½ çš„_BingX_API_KEY"
API_SECRET = "ä½ çš„_BingX_API_SECRET"
# BingX API Doc: https://bingx-api.github.io/docs/

# =======================
# ğŸ“„ Step 3: è®€å– txt æŒ‡ä»¤
# æ ¼å¼ï¼š
# BTC-USDT, LONG, 0.01, MARKET
# ETH-USDT, SHORT, 0.05, LIMIT, 3500
# =======================
TXT_PATH = "/content/input_orders.txt"

orders = []
with open(TXT_PATH, "r", encoding="utf-8") as f:
    for line in f:
        line = line.strip()
        if not line or line.startswith("#"):
            continue
        parts = [x.strip() for x in line.split(",")]
        if len(parts) < 4:
            print(f"âŒ æŒ‡ä»¤æ ¼å¼éŒ¯èª¤: {line}")
            continue
        symbol = parts[0]
        side = parts[1].upper()
        qty = float(parts[2])
        order_type = parts[3].upper()
        price = float(parts[4]) if (order_type == "LIMIT" and len(parts) > 4) else None
        orders.append({
            "symbol": symbol,
            "side": side,
            "qty": qty,
            "order_type": order_type,
            "price": price
        })

print(f"å…±ç™¼ç¾ {len(orders)} ç­†ä¸‹å–®æŒ‡ä»¤")

# =======================
# ğŸ“„ Step 4: BingX API ä¸‹å–® function
# =======================
import requests
import hashlib
import hmac
import time

def sign(payload, secret):
    return hmac.new(secret.encode(), payload.encode(), hashlib.sha256).hexdigest()

def place_order(order):
    url = "https://open-api.bingx.com/openApi/swap/v2/trade/order"  # åˆç´„ä¸‹å–®API
    timestamp = str(int(time.time() * 1000))
    params = {
        "symbol": order['symbol'],
        "side": "BUY" if order["side"] == "LONG" else "SELL",
        "positionSide": "LONG" if order["side"] == "LONG" else "SHORT",
        "quantity": order["qty"],
        "type": order["order_type"],
        "timestamp": timestamp,
        "recvWindow": 5000
    }
    if order["order_type"] == "LIMIT" and order["price"]:
        params["price"] = order["price"]

    # BingX ç‰¹æœ‰ç°½å
    query = "&".join([f"{k}={params[k]}" for k in sorted(params)])
    signature = sign(query, API_SECRET)
    params["signature"] = signature

    headers = {
        "X-BX-APIKEY": API_KEY
    }

    # å¸‚åƒ¹å–®ä¸ç”¨ price
    if order["order_type"] == "MARKET":
        params.pop("price", None)

    try:
        response = requests.post(url, params=params, headers=headers)
        resp_json = response.json()
        if resp_json.get("code") == 0:
            print(f"âœ… ä¸‹å–®æˆåŠŸ: {order['symbol']} {order['side']} {order['qty']}")
        else:
            print(f"âŒ ä¸‹å–®å¤±æ•—: {order['symbol']} {order['side']}ï¼ŒåŸå› : {resp_json.get('msg')}")
        return resp_json
    except Exception as e:
        print(f"âŒ ä¸‹å–®ç•°å¸¸: {order['symbol']} {e}")

# =======================
# ğŸ“„ Step 5: åŸ·è¡Œæ‰€æœ‰æŒ‡ä»¤
# =======================
for order in orders:
    place_order(order)

print("ğŸ‰ æ‰€æœ‰ä¸‹å–®æŒ‡ä»¤åŸ·è¡Œå®Œç•¢ï¼")



ä½ éœ€è¦çš„ TXT æª”ç¤ºä¾‹
æª”åï¼šinput_orders.txt
ï¼ˆæ”¾åˆ° /content/ï¼Œæˆ–ä½ è‡ªå·± Google Drive ç›®éŒ„ä¸‹ï¼‰

å…§å®¹ä¾‹å¦‚ï¼š
BTC-USDT, LONG, 0.01, MARKET
ETH-USDT, SHORT, 0.05, LIMIT, 3500
# é€™ä¸€è¡Œæ˜¯è¨»è§£
